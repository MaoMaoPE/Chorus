/* Generated by: JavaCC 21 Parser Generator. SNBTParserImplement.java */
package org.chorus.nbt.snbt

import org.chorus.nbt.snbt.ast.*
import java.io.*
import java.nio.charset.Charset
import java.nio.file.Files
import java.nio.file.Path
import java.util.*
import java.util.concurrent.CancellationException
import kotlin.collections.ArrayList
import kotlin.collections.HashMap
import kotlin.collections.ListIterator
import kotlin.collections.set

class SNBTParserImplement(
    /**
     * Generated Lexer.
     */
    var token_source: SNBTLexer
) : SNBTConstants {
    // The last token successfully "consumed"
    var lastConsumedToken: Token
    private var nextTokenType: SNBTConstants.TokenType? = null
    private var currentLookaheadToken: Token? = null
    private var remainingLookahead = 0
    private var hitFailure = false
    private var passedPredicate = false
    private var currentlyParsedProduction: String? = null
    private var currentLookaheadProduction: String? = null
    private var lookaheadRoutineNesting = 0
    private var passedPredicateThreshold = -1
    private val legacyGlitchyLookahead = false
    var isCancelled: Boolean = false
        private set

    fun cancel() {
        isCancelled = true
    }

    var inputSource: String?
        get() = token_source.inputSource
        set(inputSource) {
            token_source.inputSource = inputSource
        }

    //=================================
    // Generated constructors
    //=================================
    constructor(inputSource: String, content: CharSequence) : this(SNBTLexer(inputSource, content))

    constructor(content: CharSequence) : this("input", content)

    /**
     * @param inputSource just the name of the input source (typically the filename) that
     * will be used in error messages and so on.
     * @param path        The location (typically the filename) from which to get the input to parse
     */
    constructor(inputSource: String?, path: Path) : this(inputSource, stringFromBytes(Files.readAllBytes(path)))

    constructor(inputSource: String, path: Path, charset: Charset?) : this(
        inputSource, SNBTLexer.Companion.stringFromBytes(
            Files.readAllBytes(path), charset
        )
    )

    /**
     * @param path The location (typically the filename) from which to get the input to parse
     */
    constructor(path: Path) : this(path.toString(), path)

    /**
     * Use the constructor that takes a #java.nio.files.Path or just
     * a String (i.e. CharSequence) directly.
     */
    @Deprecated("")
    constructor(stream: InputStream) : this(InputStreamReader(stream))

    /**
     * Use the constructor that takes a #java.nio.files.Path or just
     * a String (i.e. CharSequence) directly.
     */
    @Deprecated("")
    constructor(reader: Reader) : this(SNBTLexer("input", reader))

    // If the next token is cached, it returns that
    // Otherwise, it goes to the token_source, i.e. the Lexer.
    private fun nextToken(tok: Token?): Token {
        var result = token_source.getNextToken(tok)
        while (result!!.isUnparsed) {
            result = token_source.getNextToken(result)
        }
        nextTokenType = null
        return result
    }

    val nextToken: Token?
        /**
         * @return the next Token off the stream. This is the same as #getToken(1)
         */
        get() = getToken(1)

    /**
     * @param index how many tokens to look ahead
     * @return the specific regular (i.e. parsed) Token index ahead/behind in the stream.
     * If we are in a lookahead, it looks ahead from the currentLookaheadToken
     * Otherwise, it is the lastConsumedToken. If you pass in a negative
     * number it goes backward.
     */
    fun getToken(index: Int): Token? {
        var t = if (currentLookaheadToken == null) lastConsumedToken else currentLookaheadToken
        for (i in 0..<index) {
            t = nextToken(t)
        }
        for (i in 0 downTo index + 1) {
            t = t.getPrevious()
            if (t == null) break
        }
        return t
    }

    private fun nextTokenType(): SNBTConstants.TokenType? {
        if (nextTokenType == null) {
            nextTokenType = nextToken(lastConsumedToken).type
        }
        return nextTokenType
    }

    fun activateTokenTypes(vararg types: SNBTConstants.TokenType?): Boolean {
        var result = false
        for (tt in types) {
            result = result or token_source.activeTokenTypes.add(tt)
        }
        if (result) {
            token_source.reset(getToken(0)!!)
            nextTokenType = null
        }
        return result
    }

    fun deactivateTokenTypes(vararg types: SNBTConstants.TokenType?): Boolean {
        var result = false
        for (tt in types) {
            result = result or token_source.activeTokenTypes.remove(tt)
        }
        if (result) {
            token_source.reset(getToken(0)!!)
            nextTokenType = null
        }
        return result
    }

    // SNBT.javacc:55:1
    fun Value() {
        if (isCancelled) throw CancellationException()
        val prevProduction = currentlyParsedProduction
        this.currentlyParsedProduction = "Value"
        // Code for ExpansionChoice specified at SNBT.javacc:56:5
        var Value1: Value? = null
        if (isTreeBuildingEnabled) {
            Value1 = org.chorus.nbt.snbt.ast.Value()
            openNodeScope(Value1)
        }
        var parseException2: ParseException? = null
        val callStackSize3 = parsingStack.size
        try {
            if (nextTokenType() == SNBTConstants.TokenType.BYTE) {
                // Code for RegexpRef specified at SNBT.javacc:56:5
                consumeToken(SNBTConstants.TokenType.BYTE)
            } else if (nextTokenType() == SNBTConstants.TokenType.BOOLEAN) {
                // Code for RegexpRef specified at SNBT.javacc:58:5
                consumeToken(SNBTConstants.TokenType.BOOLEAN)
            } else if (nextTokenType() == SNBTConstants.TokenType.STRING) {
                // Code for RegexpRef specified at SNBT.javacc:60:5
                consumeToken(SNBTConstants.TokenType.STRING)
            } else if (nextTokenType() == SNBTConstants.TokenType.SHORT) {
                // Code for RegexpRef specified at SNBT.javacc:62:5
                consumeToken(SNBTConstants.TokenType.SHORT)
            } else if (nextTokenType() == SNBTConstants.TokenType.FLOAT) {
                // Code for RegexpRef specified at SNBT.javacc:64:5
                consumeToken(SNBTConstants.TokenType.FLOAT)
            } else if (nextTokenType() == SNBTConstants.TokenType.DOUBLE) {
                // Code for RegexpRef specified at SNBT.javacc:66:5
                consumeToken(SNBTConstants.TokenType.DOUBLE)
            } else if (nextTokenType() == SNBTConstants.TokenType.LONG) {
                // Code for RegexpRef specified at SNBT.javacc:68:5
                consumeToken(SNBTConstants.TokenType.LONG)
            } else if (nextTokenType() == SNBTConstants.TokenType.INTEGER) {
                // Code for RegexpRef specified at SNBT.javacc:70:5
                consumeToken(SNBTConstants.TokenType.INTEGER)
            } else if (`scan$SNBT_javacc$72$5`()) {
                // Code for NonTerminal specified at SNBT.javacc:72:5
                pushOntoCallStack("Value", "SNBT.javacc", 72, 5)
                try {
                    ByteArrayNBT()
                } finally {
                    popCallStack()
                }
            } else if (`scan$SNBT_javacc$74$5`()) {
                // Code for NonTerminal specified at SNBT.javacc:74:5
                pushOntoCallStack("Value", "SNBT.javacc", 74, 5)
                try {
                    IntArrayNBT()
                } finally {
                    popCallStack()
                }
            } else if (nextTokenType() == SNBTConstants.TokenType.OPEN_BRACE) {
                // Code for NonTerminal specified at SNBT.javacc:76:5
                pushOntoCallStack("Value", "SNBT.javacc", 76, 5)
                try {
                    CompoundNBT()
                } finally {
                    popCallStack()
                }
            } else if (nextTokenType() == SNBTConstants.TokenType.OPEN_BRACKET) {
                // Code for NonTerminal specified at SNBT.javacc:78:5
                pushOntoCallStack("Value", "SNBT.javacc", 78, 5)
                try {
                    ListNBT()
                } finally {
                    popCallStack()
                }
            } else {
                pushOntoCallStack("Value", "SNBT.javacc", 56, 5)
                throw ParseException(this, Value_FIRST_SET, parsingStack)
            }
        } catch (e: ParseException) {
            parseException2 = e
            throw e
        } finally {
            restoreCallStack(callStackSize3)
            if (Value1 != null) {
                if (parseException2 == null) {
                    closeNodeScope(Value1, nodeArity() > 1)
                } else {
                    clearNodeScope()
                }
            }
            this.currentlyParsedProduction = prevProduction
        }
    }

    // SNBT.javacc:81:1
    fun KeyValuePair() {
        if (isCancelled) throw CancellationException()
        val prevProduction = currentlyParsedProduction
        this.currentlyParsedProduction = "KeyValuePair"
        var KeyValuePair2: KeyValuePair? = null
        if (isTreeBuildingEnabled) {
            KeyValuePair2 = org.chorus.nbt.snbt.ast.KeyValuePair()
            openNodeScope(KeyValuePair2)
        }
        var parseException102: ParseException? = null
        val callStackSize103 = parsingStack.size
        try {
            // Code for RegexpRef specified at SNBT.javacc:81:16
            consumeToken(SNBTConstants.TokenType.STRING)
            // Code for RegexpRef specified at SNBT.javacc:81:25
            consumeToken(SNBTConstants.TokenType.COLON)
            // Code for ZeroOrOne specified at SNBT.javacc:81:33
            if (`first_set$SNBT_javacc$81$34`.contains(nextTokenType())) {
                // Code for NonTerminal specified at SNBT.javacc:81:34
                pushOntoCallStack("KeyValuePair", "SNBT.javacc", 81, 34)
                try {
                    Value()
                } finally {
                    popCallStack()
                }
            }
        } catch (e: ParseException) {
            parseException102 = e
            throw e
        } finally {
            restoreCallStack(callStackSize103)
            if (KeyValuePair2 != null) {
                if (parseException102 == null) {
                    closeNodeScope(KeyValuePair2, nodeArity() > 1)
                } else {
                    clearNodeScope()
                }
            }
            this.currentlyParsedProduction = prevProduction
        }
    }

    // SNBT.javacc:83:1
    fun ByteArrayNBT() {
        if (isCancelled) throw CancellationException()
        val prevProduction = currentlyParsedProduction
        this.currentlyParsedProduction = "ByteArrayNBT"
        var ByteArrayNBT3: ByteArrayNBT? = null
        if (isTreeBuildingEnabled) {
            ByteArrayNBT3 = ByteArrayNBT()
            openNodeScope(ByteArrayNBT3)
        }
        var parseException126: ParseException? = null
        val callStackSize127 = parsingStack.size
        try {
            // Code for RegexpRef specified at SNBT.javacc:84:5
            consumeToken(SNBTConstants.TokenType.OPEN_BRACKET)
            // Code for RegexpStringLiteral specified at SNBT.javacc:84:20
            consumeToken(SNBTConstants.TokenType.B)
            // Code for RegexpStringLiteral specified at SNBT.javacc:84:24
            consumeToken(SNBTConstants.TokenType._TOKEN_17)
            // Code for ZeroOrOne specified at SNBT.javacc:84:32
            if (nextTokenType() == SNBTConstants.TokenType.BOOLEAN || nextTokenType == SNBTConstants.TokenType.BYTE) {
                if (nextTokenType() == SNBTConstants.TokenType.BYTE) {
                    // Code for RegexpRef specified at SNBT.javacc:84:35
                    consumeToken(SNBTConstants.TokenType.BYTE)
                } else if (nextTokenType() == SNBTConstants.TokenType.BOOLEAN) {
                    // Code for RegexpRef specified at SNBT.javacc:84:44
                    consumeToken(SNBTConstants.TokenType.BOOLEAN)
                } else {
                    pushOntoCallStack("ByteArrayNBT", "SNBT.javacc", 84, 35)
                    throw ParseException(this, `first_set$SNBT_javacc$84$35`, parsingStack)
                }
                // Code for ZeroOrMore specified at SNBT.javacc:84:55
                while (true) {
                    if (nextTokenType() != SNBTConstants.TokenType.COMMA) break
                    // Code for RegexpRef specified at SNBT.javacc:84:56
                    consumeToken(SNBTConstants.TokenType.COMMA)
                    if (nextTokenType() == SNBTConstants.TokenType.BYTE) {
                        // Code for RegexpRef specified at SNBT.javacc:84:65
                        consumeToken(SNBTConstants.TokenType.BYTE)
                    } else if (nextTokenType() == SNBTConstants.TokenType.BOOLEAN) {
                        // Code for RegexpRef specified at SNBT.javacc:84:74
                        consumeToken(SNBTConstants.TokenType.BOOLEAN)
                    } else {
                        pushOntoCallStack("ByteArrayNBT", "SNBT.javacc", 84, 65)
                        throw ParseException(this, `first_set$SNBT_javacc$84$65`, parsingStack)
                    }
                }
                // Code for ZeroOrOne specified at SNBT.javacc:84:87
                if (nextTokenType() == SNBTConstants.TokenType.COMMA) {
                    // Code for RegexpRef specified at SNBT.javacc:84:88
                    consumeToken(SNBTConstants.TokenType.COMMA)
                }
            }
            // Code for RegexpRef specified at SNBT.javacc:84:100
            consumeToken(SNBTConstants.TokenType.CLOSE_BRACKET)
        } catch (e: ParseException) {
            parseException126 = e
            throw e
        } finally {
            restoreCallStack(callStackSize127)
            if (ByteArrayNBT3 != null) {
                if (parseException126 == null) {
                    closeNodeScope(ByteArrayNBT3, nodeArity() > 1)
                } else {
                    clearNodeScope()
                }
            }
            this.currentlyParsedProduction = prevProduction
        }
    }

    // SNBT.javacc:86:1
    fun IntArrayNBT() {
        if (isCancelled) throw CancellationException()
        val prevProduction = currentlyParsedProduction
        this.currentlyParsedProduction = "IntArrayNBT"
        var IntArrayNBT4: IntArrayNBT? = null
        if (isTreeBuildingEnabled) {
            IntArrayNBT4 = IntArrayNBT()
            openNodeScope(IntArrayNBT4)
        }
        var parseException220: ParseException? = null
        val callStackSize221 = parsingStack.size
        try {
            // Code for RegexpRef specified at SNBT.javacc:87:5
            consumeToken(SNBTConstants.TokenType.OPEN_BRACKET)
            // Code for RegexpStringLiteral specified at SNBT.javacc:87:20
            consumeToken(SNBTConstants.TokenType.I)
            // Code for RegexpStringLiteral specified at SNBT.javacc:87:24
            consumeToken(SNBTConstants.TokenType._TOKEN_17)
            // Code for ZeroOrOne specified at SNBT.javacc:87:32
            if (nextTokenType() == SNBTConstants.TokenType.INTEGER) {
                // Code for RegexpRef specified at SNBT.javacc:87:33
                consumeToken(SNBTConstants.TokenType.INTEGER)
                // Code for ZeroOrMore specified at SNBT.javacc:87:43
                while (true) {
                    if (nextTokenType() != SNBTConstants.TokenType.COMMA) break
                    // Code for RegexpRef specified at SNBT.javacc:87:44
                    consumeToken(SNBTConstants.TokenType.COMMA)
                    // Code for RegexpRef specified at SNBT.javacc:87:52
                    consumeToken(SNBTConstants.TokenType.INTEGER)
                }
                // Code for ZeroOrOne specified at SNBT.javacc:87:64
                if (nextTokenType() == SNBTConstants.TokenType.COMMA) {
                    // Code for RegexpRef specified at SNBT.javacc:87:65
                    consumeToken(SNBTConstants.TokenType.COMMA)
                }
            }
            // Code for RegexpRef specified at SNBT.javacc:87:77
            consumeToken(SNBTConstants.TokenType.CLOSE_BRACKET)
        } catch (e: ParseException) {
            parseException220 = e
            throw e
        } finally {
            restoreCallStack(callStackSize221)
            if (IntArrayNBT4 != null) {
                if (parseException220 == null) {
                    closeNodeScope(IntArrayNBT4, nodeArity() > 1)
                } else {
                    clearNodeScope()
                }
            }
            this.currentlyParsedProduction = prevProduction
        }
    }

    // SNBT.javacc:89:1
    fun ListNBT() {
        if (isCancelled) throw CancellationException()
        val prevProduction = currentlyParsedProduction
        this.currentlyParsedProduction = "ListNBT"
        var ListNBT5: ListNBT? = null
        if (isTreeBuildingEnabled) {
            ListNBT5 = ListNBT()
            openNodeScope(ListNBT5)
        }
        var parseException280: ParseException? = null
        val callStackSize281 = parsingStack.size
        try {
            // Code for RegexpRef specified at SNBT.javacc:90:5
            consumeToken(SNBTConstants.TokenType.OPEN_BRACKET)
            // Code for ZeroOrOne specified at SNBT.javacc:90:20
            if (`first_set$SNBT_javacc$90$21`.contains(nextTokenType())) {
                // Code for NonTerminal specified at SNBT.javacc:90:21
                pushOntoCallStack("ListNBT", "SNBT.javacc", 90, 21)
                try {
                    Value()
                } finally {
                    popCallStack()
                }
                // Code for ZeroOrMore specified at SNBT.javacc:90:27
                while (true) {
                    if (nextTokenType() != SNBTConstants.TokenType.COMMA) break
                    // Code for RegexpRef specified at SNBT.javacc:90:28
                    consumeToken(SNBTConstants.TokenType.COMMA)
                    // Code for NonTerminal specified at SNBT.javacc:90:36
                    pushOntoCallStack("ListNBT", "SNBT.javacc", 90, 36)
                    try {
                        Value()
                    } finally {
                        popCallStack()
                    }
                }
            }
            // Code for RegexpRef specified at SNBT.javacc:90:46
            consumeToken(SNBTConstants.TokenType.CLOSE_BRACKET)
        } catch (e: ParseException) {
            parseException280 = e
            throw e
        } finally {
            restoreCallStack(callStackSize281)
            if (ListNBT5 != null) {
                if (parseException280 == null) {
                    closeNodeScope(ListNBT5, nodeArity() > 1)
                } else {
                    clearNodeScope()
                }
            }
            this.currentlyParsedProduction = prevProduction
        }
    }

    // SNBT.javacc:92:1
    fun CompoundNBT() {
        if (isCancelled) throw CancellationException()
        val prevProduction = currentlyParsedProduction
        this.currentlyParsedProduction = "CompoundNBT"
        var CompoundNBT6: CompoundNBT? = null
        if (isTreeBuildingEnabled) {
            CompoundNBT6 = CompoundNBT()
            openNodeScope(CompoundNBT6)
        }
        var parseException320: ParseException? = null
        val callStackSize321 = parsingStack.size
        try {
            // Code for RegexpRef specified at SNBT.javacc:92:15
            consumeToken(SNBTConstants.TokenType.OPEN_BRACE)
            // Code for ZeroOrOne specified at SNBT.javacc:92:28
            if (nextTokenType() == SNBTConstants.TokenType.STRING) {
                // Code for NonTerminal specified at SNBT.javacc:92:29
                pushOntoCallStack("CompoundNBT", "SNBT.javacc", 92, 29)
                try {
                    KeyValuePair()
                } finally {
                    popCallStack()
                }
                // Code for ZeroOrMore specified at SNBT.javacc:92:42
                while (true) {
                    if (nextTokenType() != SNBTConstants.TokenType.COMMA) break
                    // Code for RegexpRef specified at SNBT.javacc:92:43
                    consumeToken(SNBTConstants.TokenType.COMMA)
                    // Code for NonTerminal specified at SNBT.javacc:92:51
                    pushOntoCallStack("CompoundNBT", "SNBT.javacc", 92, 51)
                    try {
                        KeyValuePair()
                    } finally {
                        popCallStack()
                    }
                }
            }
            // Code for RegexpRef specified at SNBT.javacc:92:68
            consumeToken(SNBTConstants.TokenType.CLOSE_BRACE)
        } catch (e: ParseException) {
            parseException320 = e
            throw e
        } finally {
            restoreCallStack(callStackSize321)
            if (CompoundNBT6 != null) {
                if (parseException320 == null) {
                    closeNodeScope(CompoundNBT6, nodeArity() > 1)
                } else {
                    clearNodeScope()
                }
            }
            this.currentlyParsedProduction = prevProduction
        }
    }

    // SNBT.javacc:95:1
    fun Root() {
        if (isCancelled) throw CancellationException()
        val prevProduction = currentlyParsedProduction
        this.currentlyParsedProduction = "Root"
        var Root7: Root? = null
        if (isTreeBuildingEnabled) {
            Root7 = org.chorus.nbt.snbt.ast.Root()
            openNodeScope(Root7)
        }
        var parseException360: ParseException? = null
        val callStackSize361 = parsingStack.size
        try {
            // Code for NonTerminal specified at SNBT.javacc:95:8
            pushOntoCallStack("Root", "SNBT.javacc", 95, 8)
            try {
                Value()
            } finally {
                popCallStack()
            }
            // Code for EndOfFile specified at SNBT.javacc:95:14
            consumeToken(SNBTConstants.TokenType.EOF)
        } catch (e: ParseException) {
            parseException360 = e
            throw e
        } finally {
            restoreCallStack(callStackSize361)
            if (Root7 != null) {
                if (parseException360 == null) {
                    closeNodeScope(Root7, nodeArity() > 1)
                } else {
                    clearNodeScope()
                }
            }
            this.currentlyParsedProduction = prevProduction
        }
    }

    private fun scanToken(
        expectedType: SNBTConstants.TokenType,
        vararg additionalTypes: SNBTConstants.TokenType
    ): Boolean {
        val peekedToken = nextToken(currentLookaheadToken)
        val type = peekedToken.type
        if (type != expectedType) {
            var matched = false
            for (tt in additionalTypes) {
                if (type == tt) {
                    matched = true
                    break
                }
            }
            if (!matched) return false
        }
        --remainingLookahead
        currentLookaheadToken = peekedToken
        return true
    }

    private fun scanToken(types: EnumSet<SNBTConstants.TokenType?>): Boolean {
        val peekedToken = nextToken(currentLookaheadToken)
        val type = peekedToken.type
        if (!types.contains(type)) return false
        --remainingLookahead
        currentLookaheadToken = peekedToken
        return true
    }

    // scanahead routine for expansion at: 
    // SNBT.javacc:84:34
    // BuildScanRoutine macro
    private fun `check$SNBT_javacc$84$34`(scanToEnd: Boolean): Boolean {
        var `$reachedScanCode$` = false
        val passedPredicateThreshold = remainingLookahead - 1
        try {
            lookaheadRoutineNesting++
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            `$reachedScanCode$` = true
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for ExpansionChoice specified at SNBT.javacc:84:35
            if (!scanToken(SNBTConstants.TokenType.BOOLEAN, SNBTConstants.TokenType.BYTE)) return false
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for ZeroOrMore specified at SNBT.javacc:84:55
            val passedPredicate385 = passedPredicate
            try {
                while (remainingLookahead > 0 && !hitFailure) {
                    val token386 = currentLookaheadToken
                    passedPredicate = false
                    if (!`check$SNBT_javacc$84$56`(false)) {
                        if (passedPredicate && !legacyGlitchyLookahead) return false
                        currentLookaheadToken = token386
                        break
                    }
                }
            } finally {
                passedPredicate = passedPredicate385
            }
            hitFailure = false
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for ZeroOrOne specified at SNBT.javacc:84:87
            val token388 = currentLookaheadToken
            val passedPredicate388 = passedPredicate
            passedPredicate = false
            try {
                if (!scanToken(SNBTConstants.TokenType.COMMA)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false
                    currentLookaheadToken = token388
                    hitFailure = false
                }
            } finally {
                passedPredicate = passedPredicate388
            }
        } finally {
            lookaheadRoutineNesting--
            if (`$reachedScanCode$` && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true
            }
        }
        passedPredicate = false
        return true
    }

    // scanahead routine for expansion at: 
    // SNBT.javacc:84:56
    // BuildScanRoutine macro
    private fun `check$SNBT_javacc$84$56`(scanToEnd: Boolean): Boolean {
        var `$reachedScanCode$` = false
        val passedPredicateThreshold = remainingLookahead - 1
        try {
            lookaheadRoutineNesting++
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            `$reachedScanCode$` = true
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for RegexpRef specified at SNBT.javacc:84:56
            if (!scanToken(SNBTConstants.TokenType.COMMA)) return false
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for ExpansionChoice specified at SNBT.javacc:84:65
            if (!scanToken(SNBTConstants.TokenType.BOOLEAN, SNBTConstants.TokenType.BYTE)) return false
        } finally {
            lookaheadRoutineNesting--
            if (`$reachedScanCode$` && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true
            }
        }
        passedPredicate = false
        return true
    }

    // scanahead routine for expansion at: 
    // SNBT.javacc:87:33
    // BuildScanRoutine macro
    private fun `check$SNBT_javacc$87$33`(scanToEnd: Boolean): Boolean {
        var `$reachedScanCode$` = false
        val passedPredicateThreshold = remainingLookahead - 1
        try {
            lookaheadRoutineNesting++
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            `$reachedScanCode$` = true
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for RegexpRef specified at SNBT.javacc:87:33
            if (!scanToken(SNBTConstants.TokenType.INTEGER)) return false
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for ZeroOrMore specified at SNBT.javacc:87:43
            val passedPredicate396 = passedPredicate
            try {
                while (remainingLookahead > 0 && !hitFailure) {
                    val token397 = currentLookaheadToken
                    passedPredicate = false
                    if (!`check$SNBT_javacc$87$44`(false)) {
                        if (passedPredicate && !legacyGlitchyLookahead) return false
                        currentLookaheadToken = token397
                        break
                    }
                }
            } finally {
                passedPredicate = passedPredicate396
            }
            hitFailure = false
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for ZeroOrOne specified at SNBT.javacc:87:64
            val token399 = currentLookaheadToken
            val passedPredicate399 = passedPredicate
            passedPredicate = false
            try {
                if (!scanToken(SNBTConstants.TokenType.COMMA)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false
                    currentLookaheadToken = token399
                    hitFailure = false
                }
            } finally {
                passedPredicate = passedPredicate399
            }
        } finally {
            lookaheadRoutineNesting--
            if (`$reachedScanCode$` && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true
            }
        }
        passedPredicate = false
        return true
    }

    // scanahead routine for expansion at: 
    // SNBT.javacc:87:44
    // BuildScanRoutine macro
    private fun `check$SNBT_javacc$87$44`(scanToEnd: Boolean): Boolean {
        var `$reachedScanCode$` = false
        val passedPredicateThreshold = remainingLookahead - 1
        try {
            lookaheadRoutineNesting++
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            `$reachedScanCode$` = true
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for RegexpRef specified at SNBT.javacc:87:44
            if (!scanToken(SNBTConstants.TokenType.COMMA)) return false
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for RegexpRef specified at SNBT.javacc:87:52
            if (!scanToken(SNBTConstants.TokenType.INTEGER)) return false
        } finally {
            lookaheadRoutineNesting--
            if (`$reachedScanCode$` && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true
            }
        }
        passedPredicate = false
        return true
    }

    // BuildPredicateRoutine: expansion at SNBT.javacc:72:5
    private fun `scan$SNBT_javacc$72$5`(): Boolean {
        remainingLookahead = UNLIMITED
        currentLookaheadToken = lastConsumedToken
        val scanToEnd = false
        try {
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for NonTerminal specified at SNBT.javacc:72:5
            // NonTerminal ByteArrayNBT at SNBT.javacc:72:5
            pushOntoLookaheadStack("Value", "SNBT.javacc", 72, 5)
            currentLookaheadProduction = "ByteArrayNBT"
            try {
                if (!`check$ByteArrayNBT`(false)) return false
            } finally {
                popLookaheadStack()
            }
            return true
        } finally {
            lookaheadRoutineNesting = 0
            currentLookaheadToken = null
            hitFailure = false
        }
    }

    // BuildPredicateRoutine: expansion at SNBT.javacc:74:5
    private fun `scan$SNBT_javacc$74$5`(): Boolean {
        remainingLookahead = UNLIMITED
        currentLookaheadToken = lastConsumedToken
        val scanToEnd = false
        try {
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            if (hitFailure) return false
            if (remainingLookahead <= 0) {
                return true
            }
            // Lookahead Code for NonTerminal specified at SNBT.javacc:74:5
            // NonTerminal IntArrayNBT at SNBT.javacc:74:5
            pushOntoLookaheadStack("Value", "SNBT.javacc", 74, 5)
            currentLookaheadProduction = "IntArrayNBT"
            try {
                if (!`check$IntArrayNBT`(false)) return false
            } finally {
                popLookaheadStack()
            }
            return true
        } finally {
            lookaheadRoutineNesting = 0
            currentLookaheadToken = null
            hitFailure = false
        }
    }

    // BuildProductionLookaheadMethod macro
    private fun `check$ByteArrayNBT`(scanToEnd: Boolean): Boolean {
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for RegexpRef specified at SNBT.javacc:84:5
        if (!scanToken(SNBTConstants.TokenType.OPEN_BRACKET)) return false
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for RegexpStringLiteral specified at SNBT.javacc:84:20
        if (!scanToken(SNBTConstants.TokenType.B)) return false
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for RegexpStringLiteral specified at SNBT.javacc:84:24
        if (!scanToken(SNBTConstants.TokenType._TOKEN_17)) return false
        if (!scanToEnd && lookaheadStack.size <= 1) {
            if (lookaheadRoutineNesting == 0) {
                remainingLookahead = 0
            } else if (lookaheadStack.size == 1) {
                passedPredicateThreshold = remainingLookahead
            }
        }
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for ZeroOrOne specified at SNBT.javacc:84:32
        val token449 = currentLookaheadToken
        val passedPredicate449 = passedPredicate
        passedPredicate = false
        try {
            if (!`check$SNBT_javacc$84$34`(false)) {
                if (passedPredicate && !legacyGlitchyLookahead) return false
                currentLookaheadToken = token449
                hitFailure = false
            }
        } finally {
            passedPredicate = passedPredicate449
        }
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for RegexpRef specified at SNBT.javacc:84:100
        if (!scanToken(SNBTConstants.TokenType.CLOSE_BRACKET)) return false
        return true
    }

    // BuildProductionLookaheadMethod macro
    private fun `check$IntArrayNBT`(scanToEnd: Boolean): Boolean {
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for RegexpRef specified at SNBT.javacc:87:5
        if (!scanToken(SNBTConstants.TokenType.OPEN_BRACKET)) return false
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for RegexpStringLiteral specified at SNBT.javacc:87:20
        if (!scanToken(SNBTConstants.TokenType.I)) return false
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for RegexpStringLiteral specified at SNBT.javacc:87:24
        if (!scanToken(SNBTConstants.TokenType._TOKEN_17)) return false
        if (!scanToEnd && lookaheadStack.size <= 1) {
            if (lookaheadRoutineNesting == 0) {
                remainingLookahead = 0
            } else if (lookaheadStack.size == 1) {
                passedPredicateThreshold = remainingLookahead
            }
        }
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for ZeroOrOne specified at SNBT.javacc:87:32
        val token456 = currentLookaheadToken
        val passedPredicate456 = passedPredicate
        passedPredicate = false
        try {
            if (!`check$SNBT_javacc$87$33`(false)) {
                if (passedPredicate && !legacyGlitchyLookahead) return false
                currentLookaheadToken = token456
                hitFailure = false
            }
        } finally {
            passedPredicate = passedPredicate456
        }
        if (hitFailure) return false
        if (remainingLookahead <= 0) {
            return true
        }
        // Lookahead Code for RegexpRef specified at SNBT.javacc:87:77
        if (!scanToken(SNBTConstants.TokenType.CLOSE_BRACKET)) return false
        return true
    }

    var parsingStack: ArrayList<NonTerminalCall> = ArrayList()
    private val lookaheadStack = ArrayList<NonTerminalCall>()

    /**
     * Inner class that represents entering a grammar production
     */
    inner class NonTerminalCall(val sourceFile: String, val productionName: String, val line: Int, val column: Int) {
        val tokenSource: SNBTLexer
            get() = this@SNBTParserImplement.token_source

        fun createStackTraceElement(): StackTraceElement {
            return StackTraceElement("SNBTParserImplement", productionName, sourceFile, line)
        }

        fun dump(ps: PrintStream) {
            ps.println("$productionName:$line:$column")
        }
    }

    private fun pushOntoCallStack(methodName: String, fileName: String, line: Int, column: Int) {
        parsingStack.add(NonTerminalCall(fileName, methodName, line, column))
    }

    private fun popCallStack() {
        val ntc = parsingStack.removeAt(parsingStack.size - 1)
        this.currentlyParsedProduction = ntc.productionName
    }

    private fun restoreCallStack(prevSize: Int) {
        while (parsingStack.size > prevSize) {
            popCallStack()
        }
    }

    private fun pushOntoLookaheadStack(methodName: String, fileName: String, line: Int, column: Int) {
        lookaheadStack.add(NonTerminalCall(fileName, methodName, line, column))
    }

    private fun popLookaheadStack() {
        val ntc = lookaheadStack.removeAt(lookaheadStack.size - 1)
        this.currentLookaheadProduction = ntc.productionName
    }

    fun dumpLookaheadStack(ps: PrintStream) {
        val it: ListIterator<NonTerminalCall> = lookaheadStack.listIterator(lookaheadStack.size)
        while (it.hasPrevious()) {
            it.previous().dump(ps)
        }
    }

    fun dumpCallStack(ps: PrintStream) {
        val it: ListIterator<NonTerminalCall> = parsingStack.listIterator(parsingStack.size)
        while (it.hasPrevious()) {
            it.previous().dump(ps)
        }
    }

    fun dumpLookaheadCallStack(ps: PrintStream) {
        ps.println("Current Parser Production is: $currentlyParsedProduction")
        ps.println("Current Lookahead Production is: $currentLookaheadProduction")
        ps.println("---Lookahead Stack---")
        dumpLookaheadStack(ps)
        ps.println("---Call Stack---")
        dumpCallStack(ps)
    }

    var isParserTolerant: Boolean
        get() = false
        set(tolerantParsing) {
            if (tolerantParsing) {
                throw UnsupportedOperationException("This parser was not built with that feature!")
            }
        }

    private fun consumeToken(expectedType: SNBTConstants.TokenType): Token {
        var nextToken = nextToken(lastConsumedToken)
        if (nextToken.type != expectedType) {
            nextToken = handleUnexpectedTokenType(expectedType, nextToken)
        }
        this.lastConsumedToken = nextToken
        this.nextTokenType = null
        if (isTreeBuildingEnabled && tokensAreNodes) {
            pushNode(lastConsumedToken)
        }
        return lastConsumedToken
    }

    private fun handleUnexpectedTokenType(expectedType: SNBTConstants.TokenType, nextToken: Token): Token {
        throw ParseException(this, nextToken, EnumSet.of(expectedType), parsingStack)
    }

    private inner class ParseState {
        var lastConsumed: Token = lastConsumedToken
        var parsingStack: ArrayList<NonTerminalCall>
        var nodeScope: NodeScope

        init {
            val parsingStack = this@SNBTParserImplement.parsingStack.clone() as ArrayList<NonTerminalCall>
            this.parsingStack = parsingStack
            this.nodeScope = currentNodeScope.clone()
        }
    }

    var isTreeBuildingEnabled: Boolean = true
    private var tokensAreNodes = true
    private var unparsedTokensAreNodes = false

    fun setUnparsedTokensAreNodes(unparsedTokensAreNodes: Boolean) {
        this.unparsedTokensAreNodes = unparsedTokensAreNodes
    }

    fun setTokensAreNodes(tokensAreNodes: Boolean) {
        this.tokensAreNodes = tokensAreNodes
    }

    var currentNodeScope: NodeScope = NodeScope()

    /**
     * @return the root node of the AST. It only makes sense to call
     * this after a successful parse.
     */
    fun rootNode(): Node? {
        return currentNodeScope.rootNode()
    }

    /**
     * push a node onto the top of the node stack
     *
     * @param n the node to push
     */
    fun pushNode(n: Node) {
        currentNodeScope.add(n)
    }

    /**
     * @return the node on the top of the stack, and remove it from the
     * stack.
     */
    fun popNode(): Node {
        return currentNodeScope.pop()
    }

    /**
     * @return the node currently on the top of the tree-building stack.
     */
    fun peekNode(): Node? {
        return currentNodeScope.peek()
    }

    /**
     * Puts the node on the top of the stack. However, unlike pushNode()
     * it replaces the node that is currently on the top of the stack.
     * This is effectively equivalent to popNode() followed by pushNode(n)
     *
     * @param n the node to poke
     */
    fun pokeNode(n: Node?) {
        currentNodeScope.poke(n)
    }

    /**
     * @return the number of Nodes on the tree-building stack in the current node
     * scope.
     */
    fun nodeArity(): Int {
        return currentNodeScope.size
    }

    private fun clearNodeScope() {
        currentNodeScope.clear()
    }

    private fun openNodeScope(n: Node?) {
        NodeScope()
        if (n != null) {
            val next = nextToken(lastConsumedToken)
            n.tokenSource = lastConsumedToken.tokenSource
            n.beginOffset = next.beginOffset
            n.open()
        }
    }

    /* A definite node is constructed from a specified number of
     * children.  That number of nodes are popped from the stack and
     * made the children of the definite node.  Then the definite node
     * is pushed on to the stack.
     */
    private fun closeNodeScope(n: Node, num: Int) {
        n.endOffset = lastConsumedToken.endOffset
        currentNodeScope.close()
        val nodes = ArrayList<Node?>()
        for (i in 0..<num) {
            nodes.add(popNode())
        }
        Collections.reverse(nodes)
        for (child in nodes) {
            // FIXME deal with the UNPARSED_TOKENS_ARE_NODES case
            n.addChild(child)
        }
        n.close()
        pushNode(n)
    }

    /**
     * A conditional node is constructed if the condition is true.  All
     * the nodes that have been pushed since the node was opened are
     * made children of the conditional node, which is then pushed
     * on to the stack.  If the condition is false the node is not
     * constructed and they are left on the stack.
     */
    private fun closeNodeScope(n: Node?, condition: Boolean) {
        if (n != null && condition) {
            n.endOffset = lastConsumedToken.endOffset
            var a = nodeArity()
            currentNodeScope.close()
            val nodes = ArrayList<Node?>()
            while (a-- > 0) {
                nodes.add(popNode())
            }
            Collections.reverse(nodes)
            for (child in nodes) {
                if (unparsedTokensAreNodes && child is Token) {
                    var tok: Token? = child
                    while (tok!!.previousCachedToken() != null && tok.previousCachedToken()!!.isUnparsed) {
                        tok = tok.previousCachedToken()
                    }
                    while (tok!!.isUnparsed) {
                        n.addChild(tok)
                        tok = tok.nextCachedToken()
                    }
                }
                n.addChild(child)
            }
            n.close()
            pushNode(n)
        } else {
            currentNodeScope.close()
        }
    }

    /**
     * Just a kludge so that existing jjtree-based code that uses
     * parser.jjtree.foo can work without change.
     */
    var jjtree: SNBTParserImplement = this

    /**
     * Constructor with user supplied Lexer.
     */
    init {
        lastConsumedToken = token_source.DUMMY_START_TOKEN
        lastConsumedToken.tokenSource = token_source
    }

    inner class NodeScope : ArrayList<Node?>() {
        var parentScope: NodeScope

        init {
            this.parentScope = this@SNBTParserImplement.currentNodeScope
            this@SNBTParserImplement.currentNodeScope = this
        }

        val isRootScope: Boolean
            get() = parentScope == null

        fun rootNode(): Node? {
            var ns = this
            while (ns.parentScope != null) {
                ns = ns.parentScope
            }
            return if (ns.isEmpty()) null else ns[0]
        }

        fun peek(): Node? {
            if (isEmpty()) {
                return if (parentScope == null) null else parentScope.peek()
            }
            return get(size - 1)
        }

        fun pop(): Node {
            return if (isEmpty()) parentScope.pop() else removeAt(size - 1)!!
        }

        fun poke(n: Node?) {
            if (isEmpty()) {
                parentScope.poke(n)
            } else {
                set(size - 1, n)
            }
        }

        fun close() {
            parentScope.addAll(this)
            this@SNBTParserImplement.currentNodeScope = parentScope
        }

        fun nestingLevel(): Int {
            var result = 0
            var parent = this
            while (parent.parentScope != null) {
                result++
                parent = parent.parentScope
            }
            return result
        }

        override fun clone(): NodeScope {
            val clone = super.clone() as NodeScope
            if (parentScope != null) {
                clone.parentScope = parentScope.clone()
            }
            return clone
        }
    }

    companion object {
        const val UNLIMITED: Int = Int.MAX_VALUE
        private val enumSetCache = HashMap<Array<SNBTConstants.TokenType?>, EnumSet<SNBTConstants.TokenType?>>()

        private fun tokenTypeSet(
            first: SNBTConstants.TokenType,
            vararg rest: SNBTConstants.TokenType
        ): EnumSet<SNBTConstants.TokenType?> {
            val key = arrayOfNulls<SNBTConstants.TokenType>(1 + rest.size)
            key[0] = first
            if (rest.size > 0) {
                System.arraycopy(rest, 0, key, 1, rest.size)
            }
            Arrays.sort(key)
            if (enumSetCache.containsKey(key)) {
                return enumSetCache[key]!!
            }
            val result = if (rest.size == 0) EnumSet.of(first) else EnumSet.of(first, *rest)
            enumSetCache[key] = result
            return result
        }

        //=================================
        // Start of methods for BNF Productions
        //This code is generated by the ParserProductions.java.ftl template. 
        //=================================
        private val Value_FIRST_SET = Value_FIRST_SET_init()

        private fun Value_FIRST_SET_init(): EnumSet<SNBTConstants.TokenType?> {
            return tokenTypeSet(
                SNBTConstants.TokenType.OPEN_BRACKET,
                SNBTConstants.TokenType.OPEN_BRACE,
                SNBTConstants.TokenType.BOOLEAN,
                SNBTConstants.TokenType.FLOAT,
                SNBTConstants.TokenType.DOUBLE,
                SNBTConstants.TokenType.INTEGER,
                SNBTConstants.TokenType.LONG,
                SNBTConstants.TokenType.BYTE,
                SNBTConstants.TokenType.SHORT,
                SNBTConstants.TokenType.STRING
            )
        }

        private val `first_set$SNBT_javacc$81$34` = `first_set$SNBT_javacc$81$34_init`()

        private fun `first_set$SNBT_javacc$81$34_init`(): EnumSet<SNBTConstants.TokenType?> {
            return tokenTypeSet(
                SNBTConstants.TokenType.OPEN_BRACKET,
                SNBTConstants.TokenType.OPEN_BRACE,
                SNBTConstants.TokenType.BOOLEAN,
                SNBTConstants.TokenType.FLOAT,
                SNBTConstants.TokenType.DOUBLE,
                SNBTConstants.TokenType.INTEGER,
                SNBTConstants.TokenType.LONG,
                SNBTConstants.TokenType.BYTE,
                SNBTConstants.TokenType.SHORT,
                SNBTConstants.TokenType.STRING
            )
        }

        private val `first_set$SNBT_javacc$84$35` =
            tokenTypeSet(SNBTConstants.TokenType.BOOLEAN, SNBTConstants.TokenType.BYTE)
        private val `first_set$SNBT_javacc$84$65` =
            tokenTypeSet(SNBTConstants.TokenType.BOOLEAN, SNBTConstants.TokenType.BYTE)
        private val `first_set$SNBT_javacc$90$21` = `first_set$SNBT_javacc$90$21_init`()

        private fun `first_set$SNBT_javacc$90$21_init`(): EnumSet<SNBTConstants.TokenType?> {
            return tokenTypeSet(
                SNBTConstants.TokenType.OPEN_BRACKET,
                SNBTConstants.TokenType.OPEN_BRACE,
                SNBTConstants.TokenType.BOOLEAN,
                SNBTConstants.TokenType.FLOAT,
                SNBTConstants.TokenType.DOUBLE,
                SNBTConstants.TokenType.INTEGER,
                SNBTConstants.TokenType.LONG,
                SNBTConstants.TokenType.BYTE,
                SNBTConstants.TokenType.SHORT,
                SNBTConstants.TokenType.STRING
            )
        }
    }
}

