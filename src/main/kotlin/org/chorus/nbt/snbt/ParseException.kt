/* Generated by: JavaCC 21 Parser Generator. ParseException.java */
package org.chorus.nbt.snbt

import org.chorus.nbt.snbt.SNBTParserImplement.NonTerminalCall
import java.io.PrintStream
import java.util.*

class ParseException : RuntimeException, SNBTConstants {
    /**
     * Returns the token which causes the parse error and null otherwise.
     *
     * @return the token which causes the parse error and null otherwise.
     */
    // The token we tripped up on.
    var token: Token? = null
        private set

    //We were expecting one of these token types
    private var expectedTypes: EnumSet<SNBTConstants.TokenType?>? = null
    private var callStack: List<NonTerminalCall>? = null
    private var alreadyAdjusted = false
    var parser: SNBTParserImplement? = null
        private set

    private fun setInfo(
        parser: SNBTParserImplement,
        token: Token?,
        expectedTypes: EnumSet<SNBTConstants.TokenType?>?,
        callStack: List<NonTerminalCall>
    ) {
        var token = token
        this.parser = parser
        if (token != null && token.type != SNBTConstants.TokenType.EOF && token.next != null) {
            token = token.next
        }
        this.token = token
        this.expectedTypes = expectedTypes
        this.callStack = ArrayList(callStack)
    }

    fun hitEOF(): Boolean {
        return token != null && token.getType() == SNBTConstants.TokenType.EOF
    }

    constructor(
        parser: SNBTParserImplement,
        token: Token?,
        expectedTypes: EnumSet<SNBTConstants.TokenType?>?,
        callStack: List<NonTerminalCall>
    ) {
        setInfo(parser, token, expectedTypes, callStack)
    }

    constructor(parser: SNBTParserImplement, message: String?) : super(message) {
        setInfo(parser, parser.lastConsumedToken, null, parser.parsingStack)
    }

    constructor(
        parser: SNBTParserImplement,
        expectedTypes: EnumSet<SNBTConstants.TokenType?>?,
        callStack: List<NonTerminalCall>
    ) : this(parser, parser.lastConsumedToken, expectedTypes, callStack)

    constructor(token: Token?) {
        this.token = token
    }

    // Needed because of inheritance
    constructor() : super()

    // Needed because of inheritance
    constructor(message: String?) : super(message)

    override val message: String
        get() {
            val msg = super.message
            if (token == null && expectedTypes == null) {
                return msg!!
            }
            val buf = StringBuilder()
            if (msg != null) buf.append(msg)
            buf.append(
                """
                    
                    Encountered an error at (or somewhere around) ${token.getLocation()}
                    """.trimIndent()
            )
            if (expectedTypes != null && token != null && expectedTypes!!.contains(token.getType())) {
                return buf.toString()
            }
            if (expectedTypes != null) {
                buf.append("\nWas expecting one of the following:\n")
                var isFirst = true
                for (type in expectedTypes!!) {
                    if (!isFirst) buf.append(", ")
                    isFirst = false
                    buf.append(type)
                }
            }
            var content = token!!.image
            if (content == null) content = ""
            if (content.length > 32) content = content.substring(0, 32) + "..."
            buf.append(
                """
Found string "${SNBTLexer.Companion.addEscapes(content)}" of type ${token.getType()}"""
            )
            return buf.toString()
        }

    override fun getStackTrace(): Array<StackTraceElement> {
        adjustStackTrace()
        return super.getStackTrace()
    }

    override fun printStackTrace(s: PrintStream) {
        adjustStackTrace()
        super.printStackTrace(s)
    }

    private fun adjustStackTrace() {
        if (alreadyAdjusted || callStack == null || callStack!!.isEmpty()) return
        val fullTrace: MutableList<StackTraceElement> = LinkedList()
        val ourCallStack: MutableList<StackTraceElement> = LinkedList()
        for (ntc in callStack!!) {
            ourCallStack.add(ntc.createStackTraceElement())
        }
        val jvmCallStack = super.getStackTrace()
        for (regularEntry in jvmCallStack) {
            if (ourCallStack.isEmpty()) break
            val methodName = regularEntry.methodName
            val ourEntry = lastElementWithName(ourCallStack, methodName)
            if (ourEntry != null) {
                fullTrace.add(ourEntry)
            }
            fullTrace.add(regularEntry)
        }
        val result = arrayOfNulls<StackTraceElement>(fullTrace.size)
        setStackTrace(fullTrace.toArray(result))
        alreadyAdjusted = true
    }

    private fun lastElementWithName(elements: MutableList<StackTraceElement>, methodName: String): StackTraceElement? {
        val it = elements.listIterator(elements.size)
        while (it.hasPrevious()) {
            val elem = it.previous()
            if (elem.methodName == methodName) {
                it.remove()
                return elem
            }
        }
        return null
    }
}


