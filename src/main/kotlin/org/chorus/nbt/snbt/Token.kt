/* Generated by: JavaCC 21 Parser Generator. Token.java */
package org.chorus.nbt.snbt

import org.chorus.nbt.snbt.ast.Delimiter
import org.chorus.nbt.snbt.ast.Literal
import org.chorus.nbt.snbt.ast.WHITESPACE
import java.util.*

open class Token : SNBTConstants, Node {
    /**
     * Return the TokenType of this Token object
     */
    var type: SNBTConstants.TokenType? = null
        protected set
    override var tokenSource: SNBTLexer? = null
        get() {
            var flm = field
            // If this is null, and we have chained tokens,
            // we try to get it from there! (Why not?)
            if (flm == null) {
                if (prependedToken != null) {
                    flm = prependedToken!!.tokenSource
                }
                if (flm == null && appendedToken != null) {
                    flm = appendedToken!!.tokenSource
                }
            }
            return flm
        }

    override var beginOffset: Int = 0
    override var endOffset: Int = 0
    override var isUnparsed: Boolean = false
    override var parent: Node? = null
    private var image: String? = null

    fun setImage(image: String?) {
        this.image = image
    }

    private var prependedToken: Token? = null
    private var appendedToken: Token? = null
    var isInserted: Boolean = false
        private set

    fun preInsert(prependedToken: Token) {
        if (prependedToken === this.prependedToken) return
        prependedToken.appendedToken = this
        val existingPreviousToken = this.previousCachedToken()
        if (existingPreviousToken != null) {
            existingPreviousToken.appendedToken = prependedToken
            prependedToken.prependedToken = existingPreviousToken
        }
        prependedToken.isInserted = true
        prependedToken.endOffset = this.beginOffset
        prependedToken.beginOffset = prependedToken.endOffset
        this.prependedToken = prependedToken
    }

    fun unsetAppendedToken() {
        this.appendedToken = null
    }

    /**
     * @param type        the #TokenType of the token being constructed
     * @param image       the String content of the token
     * @param tokenSource the object that vended this token.
     */
    constructor(type: SNBTConstants.TokenType?, image: String?, tokenSource: SNBTLexer?) {
        this.type = type
        this.image = image
        this.tokenSource = tokenSource
    }

    val isVirtual: Boolean
        /**
         * @return whether this Token represent actual input or was it inserted somehow?
         */
        get() = type == SNBTConstants.TokenType.EOF

    val isSkipped: Boolean
        /**
         * @return Did we skip this token in parsing?
         */
        get() = false

    /**
     * @return the string image of the token.
     */
    fun getImage(): String {
        return if (image != null) image!! else source!!
    }

    val next: Token?
        /**
         * @return the next _cached_ regular (i.e. parsed) token
         * or null
         */
        get() = nextParsedToken

    val previous: Token?
        /**
         * @return the previous regular (i.e. parsed) token
         * or null
         */
        get() {
            var result = previousCachedToken()
            while (result != null && result.isUnparsed) {
                result = result.previousCachedToken()
            }
            return result
        }

    private val nextParsedToken: Token?
        /**
         * @return the next regular (i.e. parsed) token
         */
        get() {
            var result = nextCachedToken()
            while (result != null && result.isUnparsed) {
                result = result.nextCachedToken()
            }
            return result
        }

    /**
     * @return the next token of any sort (parsed or unparsed or invalid)
     */
    fun nextCachedToken(): Token? {
        if (type == SNBTConstants.TokenType.EOF) return null
        if (appendedToken != null) return appendedToken
        val tokenSource = tokenSource
        return tokenSource?.nextCachedToken(endOffset)
    }

    fun previousCachedToken(): Token? {
        if (prependedToken != null) return prependedToken
        if (tokenSource == null) return null
        return tokenSource!!.previousCachedToken(beginOffset)
    }

    val previousToken: Token?
        get() = previousCachedToken()

    fun replaceType(type: SNBTConstants.TokenType): Token {
        val result = newToken(type, tokenSource, beginOffset, endOffset)
        result.prependedToken = this.prependedToken
        result.appendedToken = this.appendedToken
        result.isInserted = this.isInserted
        if (result.appendedToken != null) {
            result.appendedToken!!.prependedToken = result
        }
        if (result.prependedToken != null) {
            result.prependedToken!!.appendedToken = result
        }
        if (!result.isInserted) {
            tokenSource!!.cacheToken(result)
        }
        return result
    }

    override val source: String?
        get() {
            if (type == SNBTConstants.TokenType.EOF) return ""
            val flm = tokenSource
            return flm?.getText(beginOffset, endOffset)
        }

    constructor()

    constructor(type: SNBTConstants.TokenType?, tokenSource: SNBTLexer?, beginOffset: Int, endOffset: Int) {
        this.type = type
        this.tokenSource = tokenSource
        this.beginOffset = beginOffset
        this.endOffset = endOffset
    }

    override fun clearChildren() {
    }

    open val normalizedText: String
        get() {
            if (type == SNBTConstants.TokenType.EOF) {
                return "EOF"
            }
            return getImage()
        }

    override fun toString(): String {
        return normalizedText
    }

    /**
     * @return An iterator of the tokens preceding this one.
     */
    fun precedingTokens(): Iterator<Token> {
        return object : Iterator<Token> {
            var currentPoint: Token = this@Token

            override fun hasNext(): Boolean {
                return currentPoint.previousCachedToken() != null
            }

            override fun next(): Token {
                val previous = currentPoint.previousCachedToken() ?: throw NoSuchElementException("No previous token!")
                return previous.also { currentPoint = it }
            }
        }
    }

    /**
     * @return a list of the unparsed tokens preceding this one in the order they appear in the input
     */
    fun precedingUnparsedTokens(): List<Token> {
        val result: MutableList<Token> = ArrayList()
        var t = this.previousCachedToken()
        while (t != null && t.isUnparsed) {
            result.add(t)
            t = t.previousCachedToken()
        }
        return result.reversed()
    }

    /**
     * @return An iterator of the (cached) tokens that follow this one.
     */
    fun followingTokens(): Iterator<Token> {
        return object : Iterator<Token> {
            var currentPoint: Token = this@Token

            override fun hasNext(): Boolean {
                return currentPoint.nextCachedToken() != null
            }

            override fun next(): Token {
                val next = currentPoint.nextCachedToken() ?: throw NoSuchElementException("No next token!")
                return next.also { currentPoint = it }
            }
        }
    }

    /**
     * Copy the location info from a Node
     */
    override fun copyLocationInfo(from: Node) {
        super.copyLocationInfo(from)
        if (from is Token) {
            val otherTok = from
            appendedToken = otherTok.appendedToken
            prependedToken = otherTok.prependedToken
        }
        tokenSource = (from.tokenSource)
    }

    override fun copyLocationInfo(start: Node, end: Node) {
        super.copyLocationInfo(start, end)
        if (start is Token) {
            prependedToken = start.prependedToken
        }
        if (end is Token) {
            appendedToken = end.appendedToken
        }
    }

    override val location: String
        get() = "$inputSource:$beginLine:$beginColumn"

    override fun setChild(i: Int, n: Node) {
        throw UnsupportedOperationException()
    }

    override fun addChild(n: Node) {
        throw UnsupportedOperationException()
    }

    override fun addChild(i: Int, n: Node) {
        throw UnsupportedOperationException()
    }

    override fun removeChild(i: Int): Node? {
        throw UnsupportedOperationException()
    }

    override fun indexOf(n: Node): Int {
        return -1
    }

    override val childCount: Int
        get() = 0

    override fun getChild(i: Int): Node? {
        return null
    }

    override fun children(): List<Node> {
        return emptyList()
    }

    companion object {
        fun newToken(type: SNBTConstants.TokenType, image: String?, tokenSource: SNBTLexer?): Token {
            val result = newToken(type, tokenSource, 0, 0)
            result.setImage(image)
            return result
        }

        fun newToken(type: SNBTConstants.TokenType, tokenSource: SNBTLexer?, beginOffset: Int, endOffset: Int): Token {
            return when (type) {
                SNBTConstants.TokenType.WHITESPACE -> WHITESPACE(
                    SNBTConstants.TokenType.WHITESPACE,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.COLON -> Delimiter(
                    SNBTConstants.TokenType.COLON,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.COMMA -> Delimiter(
                    SNBTConstants.TokenType.COMMA,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.OPEN_BRACKET -> Delimiter(
                    SNBTConstants.TokenType.OPEN_BRACKET,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.CLOSE_BRACKET -> Delimiter(
                    SNBTConstants.TokenType.CLOSE_BRACKET,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.OPEN_BRACE -> Delimiter(
                    SNBTConstants.TokenType.OPEN_BRACE,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.CLOSE_BRACE -> Delimiter(
                    SNBTConstants.TokenType.CLOSE_BRACE,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.BOOLEAN -> Literal(
                    SNBTConstants.TokenType.BOOLEAN,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.FLOAT -> Literal(
                    SNBTConstants.TokenType.FLOAT,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.DOUBLE -> Literal(
                    SNBTConstants.TokenType.DOUBLE,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.INTEGER -> Literal(
                    SNBTConstants.TokenType.INTEGER,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.LONG -> Literal(
                    SNBTConstants.TokenType.LONG,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.BYTE -> Literal(
                    SNBTConstants.TokenType.BYTE,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.SHORT -> Literal(
                    SNBTConstants.TokenType.SHORT,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.STRING -> Literal(
                    SNBTConstants.TokenType.STRING,
                    tokenSource,
                    beginOffset,
                    endOffset
                )

                SNBTConstants.TokenType.INVALID -> InvalidToken(tokenSource, beginOffset, endOffset)
                else -> Token(type, tokenSource, beginOffset, endOffset)
            }
        }
    }
}


