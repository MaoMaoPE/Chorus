/* Generated by: JavaCC 21 Parser Generator. Node.java */
package org.chorus.nbt.snbt

import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method
import java.lang.reflect.Modifier
import java.util.*
import java.util.concurrent.ConcurrentHashMap
import java.util.function.Predicate
import kotlin.collections.set

interface Node : Comparable<Node> {
    /**
     * Life-cycle hook method called after the node has been made the current
     * node
     */
    fun open() {
    }

    /**
     * Life-cycle hook method called after all the child nodes have been
     * added.
     */
    fun close() {
    }

    val inputSource: String
        /**
         * @return the input source (usually a filename) from which this Node came from
         */
        get() {
            val tokenSource = tokenSource
            return if (tokenSource == null) "input" else tokenSource.inputSource
        }

    /**
     * Returns whether this node has any children.
     *
     * @return Returns `true` if this node has any children,
     * `false` otherwise.
     */
    fun hasChildNodes(): Boolean {
        return childCount > 0
    }

    /**
     * @return this node's parent Node
     */
    /**
     * @param n The Node to set as the parent. Mostly used internally.
     * The various addChild or appendChild sorts of methods should use this
     * to set the node's parent.
     */
    var parent: Node?

    // The following 9 methods will typically just 
    // delegate straightforwardly to a List object that
    // holds the child nodes
    /**
     * appends a child node to this Node
     *
     * @param n the Node to append
     */
    fun addChild(n: Node)

    /**
     * inserts a child Node at a specific index, displacing the
     * nodes after the index by 1.
     *
     * @param i the (zero-based) index at which to insert the node
     * @param n the Node to insert
     */
    fun addChild(i: Int, n: Node)

    /**
     * @param i the index of the Node to return
     * @return the Node at the specific offset
     */
    fun getChild(i: Int): Node?

    /**
     * Replace the node at index i
     *
     * @param i the index
     * @param n the node
     */
    fun setChild(i: Int, n: Node)

    /**
     * Remove the node at index i. Any Nodes after i
     * are shifted to the left.
     *
     * @param i the index at which to remove
     * @return the removed Node
     */
    fun removeChild(i: Int): Node?

    /**
     * Removes the Node from this node's children
     *
     * @param n the Node to remove
     * @return whether the Node was present
     */
    fun removeChild(n: Node): Boolean {
        val index = indexOf(n)
        if (index == -1) return false
        removeChild(index)
        return true
    }

    /**
     * Replaces a child node with another one. It does
     * nothing if the first parameter is not actually a child node.
     *
     * @param current     the Node to be replaced
     * @param replacement the Node to substitute
     * @return whether any replacement took place
     */
    fun replaceChild(current: Node, replacement: Node): Boolean {
        val index = indexOf(current)
        if (index == -1) return false
        setChild(index, replacement)
        return true
    }

    /**
     * Insert a Node right before a given Node. It does nothing
     * if the where Node is not actually a child node.
     *
     * @param where    the Node that is the location where to prepend
     * @param inserted the Node to prepend
     * @return whether a Node was prepended
     */
    fun prependChild(where: Node, inserted: Node): Boolean {
        val index = indexOf(where)
        if (index == -1) return false
        addChild(index, inserted)
        return true
    }

    /**
     * Insert a node right after a given Node. It does nothing
     * if the where node is not actually a child node.
     *
     * @param where    the Node after which to append
     * @param inserted the Node to be inserted
     * @return whether a Node really was appended
     */
    fun appendChild(where: Node, inserted: Node): Boolean {
        val index = indexOf(where)
        if (index == -1) return false
        addChild(index + 1, inserted)
        return true
    }

    /**
     * @param child the Node to get the index of
     * @return the index of the child Node. Or -1 if it is not
     * a child Node.
     */
    fun indexOf(child: Node): Int {
        for (i in 0..<childCount) {
            if (child === getChild(i)) {
                return i
            }
        }
        return -1
    }

    fun previousSibling(): Node? {
        val parent = parent ?: return null
        val idx = parent.indexOf(this)
        if (idx <= 0) return null
        return parent.getChild(idx - 1)
    }

    fun nextSibling(): Node? {
        val parent = parent ?: return null
        val idx = parent.indexOf(this)
        if (idx >= parent.childCount - 1) return null
        return parent.getChild(idx + 1)
    }

    /**
     * Used to order Nodes by location.
     *
     * @param n the Node to compare to
     * @return typical Comparator semantics
     */
    override fun compareTo(n: Node): Int {
        if (this === n) return 0
        var diff = this.beginLine - n.beginLine
        if (diff != 0) return diff
        diff = this.beginColumn - n.beginColumn
        if (diff != 0) return diff
        // A child node is considered to come after its parent.
        diff = n.endLine - this.endLine
        if (diff != 0) return diff
        return n.endColumn - this.endColumn
    }

    /**
     * Remove all the child nodes
     */
    fun clearChildren()

    /**
     * @return the number of child nodes
     */
    val childCount: Int

    /**
     * @return a List containing this node's child nodes
     * The default implementation returns a copy, so modifying the
     * list that is returned has no effect on this object. Most
     * implementations of this should similarly return a copy or
     * possibly immutable wrapper around the list.
     */
    fun children(includeUnparsedTokens: Boolean): List<Node> {
        val result: MutableList<Node> = ArrayList()
        for (i in 0..<childCount) {
            val child = getChild(i)
            if (includeUnparsedTokens && child is Token) {
                val tok = child
                if (!tok.isUnparsed) {
                    result.addAll(tok.precedingUnparsedTokens())
                }
            }
            result.add(child!!)
        }
        return result
    }

    fun children(): List<Node> {
        return children(false)
    }

    /**
     * @param includeCommentTokens Whether to include comment tokens
     * @return a List containing all the tokens in a Node
     */
    fun getAllTokens(includeCommentTokens: Boolean): List<Token?> {
        val result: MutableList<Token?> = ArrayList()
        val it: Iterator<Node> = iterator()
        while (it.hasNext()) {
            val child = it.next()
            if (child is Token) {
                val token = child
                if (token.isUnparsed) {
                    continue
                }
                if (includeCommentTokens) {
                    result.addAll(token.precedingUnparsedTokens())
                }
                result.add(token)
            } else if (child.childCount > 0) {
                result.addAll(child.getAllTokens(includeCommentTokens))
            }
        }
        return result
    }

    val realTokens: List<Token>
        /**
         * @return All the tokens in the node that
         * are "real" (i.e. participate in parsing)
         */
        get() = descendants(
            Token::class.java
        ) { t: Token -> !t.isUnparsed }

    /**
     * @return the #SNBTLexer from which this Node object
     * originated. There is no guarantee that this doesn't return null.
     * Most likely that would simply be because you constructed the
     * Node yourself, i.e. it didn't really come about via the parsing/tokenizing
     * machinery.
     */
    var tokenSource: SNBTLexer?

    val source: String?
        /**
         * @return the original source content this Node came from
         * a reference to the #SNBTLexer that stores the source code and
         * the start/end location info stored in the Node object itself.
         * This method could throw a NullPointerException if #getTokenSource
         * returns null. Also, the return value could be spurious if
         * the content of the source file was changed meanwhile. But
         * this is just the default implementation of an API and it does not
         * address this problem!
         */
        get() {
            val tokenSource = tokenSource
            return tokenSource?.getText(beginOffset, endOffset)
        }

    val length: Int
        get() = 1 + endOffset - beginOffset

    val beginLine: Int
        /**
         * @return the (1-based) line location where this Node starts
         */
        get() {
            val tokenSource = tokenSource
            return tokenSource?.getLineFromOffset(beginOffset) ?: 0
        }


    val endLine: Int
        /**
         * @return the (1-based) line location where this Node ends
         */
        get() {
            val tokenSource = tokenSource
            return tokenSource?.getLineFromOffset(endOffset - 1) ?: 0
        }


    val beginColumn: Int
        /**
         * @return the (1-based) column where this Node starts
         */
        get() {
            val tokenSource = tokenSource
            return tokenSource?.getCodePointColumnFromOffset(beginOffset) ?: 0
        }


    val endColumn: Int
        /**
         * @return the (1-based) column offset where this Node ends
         */
        get() {
            val tokenSource = tokenSource
            return tokenSource?.getCodePointColumnFromOffset(endOffset - 1) ?: 0
        }

    /**
     * @return the offset in the input source where the token begins,
     * expressed in code units.
     */
    /**
     * Set the offset where the token begins, expressed in code units.
     */
    var beginOffset: Int

    /**
     * @return the offset in the input source where the token ends,
     * expressed in code units. This is actually the offset where the
     * very next token would begin.
     */
    /**
     * Set the offset where the token ends, actually the location where
     * the very next token should begin.
     */
    var endOffset: Int

    val location: String
        /**
         * @return a String that gives the starting location of this Node. This is a default
         * implementation that could be overridden
         */
        get() = "$inputSource:$beginLine:$beginColumn"

    /**
     * Mark whether this Node is unparsed, i.e. *not* the result of
     * normal parsing
     *
     * @param b whether to set the Node as unparsed or parsed.
     */
    val isUnparsed: Boolean
        /**
         * @return whether this Node was created by regular operations of the
         * parsing machinery.
         */
        get() = false

    fun <T : Node?> firstChildOfType(clazz: Class<T>): T? {
        for (i in 0..<childCount) {
            val child = getChild(i)
            if (clazz.isInstance(child)) return clazz.cast(child)
        }
        return null
    }

    fun <T : Node?> firstChildOfType(clazz: Class<T>, pred: Predicate<T>): T? {
        for (i in 0..<childCount) {
            val child = getChild(i)
            if (clazz.isInstance(child)) {
                val t = clazz.cast(child)
                if (pred.test(t)) return t
            }
        }
        return null
    }

    fun firstDescendantOfType(type: SNBTConstants.TokenType): Token? {
        for (i in 0..<childCount) {
            val child = getChild(i)
            if (child is Token) {
                val tok = child
                if (tok.type == type) {
                    return tok
                }
            } else {
                val tok = child!!.firstDescendantOfType(type)
                if (tok != null) return tok
            }
        }
        return null
    }

    fun firstChildOfType(tokenType: SNBTConstants.TokenType): Token? {
        for (i in 0..<childCount) {
            val child = getChild(i)
            if (child is Token) {
                val tok = child
                if (tok.type == tokenType) return tok
            }
        }
        return null
    }

    fun <T : Node?> firstDescendantOfType(clazz: Class<T>): T? {
        for (i in 0..<childCount) {
            val child = getChild(i)
            if (clazz.isInstance(child)) return clazz.cast(child)
            else {
                val descendant = child!!.firstDescendantOfType(clazz)
                if (descendant != null) return descendant
            }
        }
        return null
    }

    fun <T : Node?> childrenOfType(clazz: Class<T>): List<T> {
        val result: MutableList<T> = ArrayList()
        for (i in 0..<childCount) {
            val child = getChild(i)
            if (clazz.isInstance(child)) {
                result.add(clazz.cast(child))
            }
        }
        return result
    }

    fun <T : Node?> descendantsOfType(clazz: Class<T>): List<T> {
        val result: MutableList<T> = ArrayList()
        for (i in 0..<childCount) {
            val child = getChild(i)
            if (clazz.isInstance(child)) {
                result.add(clazz.cast(child))
            }
            result.addAll(child!!.descendantsOfType(clazz))
        }
        return result
    }

    fun <T : Node?> firstAncestorOfType(clazz: Class<T>): T? {
        var parent: Node? = this
        while (parent != null) {
            parent = parent.parent
            if (clazz.isInstance(parent)) {
                return clazz.cast(parent)
            }
        }
        return null
    }

    val tokenType: SNBTConstants.TokenType?
        get() = if (this is Token) this.type else null

    val firstToken: Token?
        /**
         * @return the very first token that is part of this node.
         * It may be an unparsed (i.e. special) token.
         */
        get() {
            val first = firstChild ?: return null
            if (first is Token) {
                var tok: Token = first
                while (tok.previousCachedToken() != null && tok.previousCachedToken()!!.isUnparsed) {
                    tok = tok.previousCachedToken()!!
                }
                return tok
            }
            return first.firstToken
        }

    val lastToken: Token?
        get() {
            val last = lastChild ?: return null
            if (last is Token) {
                return last
            }
            return last.lastToken
        }

    /**
     * Copy the location info from another Node
     *
     * @param from the Node to copy the info from
     */
    fun copyLocationInfo(from: Node) {
        tokenSource = from.tokenSource
        beginOffset = from.beginOffset
        endOffset = from.endOffset
        tokenSource = from.tokenSource
    }

    /**
     * Copy the location info given a start and end Node
     *
     * @param start the start node
     * @param end   the end node
     */
    fun copyLocationInfo(start: Node, end: Node) {
        tokenSource = start.tokenSource
        if (tokenSource == null) tokenSource = end.tokenSource
        beginOffset = start.beginOffset
        endOffset = end.endOffset
    }

    fun replace(toBeReplaced: Node) {
        copyLocationInfo(toBeReplaced)
        val parent = toBeReplaced.parent
        if (parent != null) {
            val index = parent.indexOf(toBeReplaced)
            parent.setChild(index, this)
        }
    }

    val firstChild: Node?
        /**
         * Returns the first child of this node. If there is no such node, this returns
         * `null`.
         *
         * @return the first child of this node. If there is no such node, this returns
         * `null`.
         */
        get() = if (childCount > 0) getChild(0) else null

    val lastChild: Node?
        /**
         * Returns the last child of the given node. If there is no such node, this
         * returns `null`.
         *
         * @return the last child of the given node. If there is no such node, this
         * returns `null`.
         */
        get() {
            val count = childCount
            return if (count > 0) getChild(count - 1) else null
        }

    val root: Node
        get() {
            var parent = this
            while (parent.parent != null) {
                parent = parent.parent!!
            }
            return parent
        }

    fun descendants(): List<Node> {
        return descendants(Node::class.java, null)
    }

    fun descendants(predicate: Predicate<in Node>?): List<Node> {
        return descendants(Node::class.java, predicate)
    }

    fun <T : Node?> descendants(clazz: Class<T>): List<T> {
        return descendants(clazz, null)
    }

    fun <T : Node?> descendants(clazz: Class<T>, predicate: Predicate<in T>?): List<T> {
        val result: MutableList<T> = ArrayList()
        for (child in children()) {
            if (clazz.isInstance(child)) {
                val t = clazz.cast(child)
                if (predicate == null || predicate.test(t)) {
                    result.add(t)
                }
            }
            result.addAll(child.descendants(clazz, predicate))
        }
        return result
    }

    fun dump(prefix: String = "") {
        val output = if (this is Token) {
            toString().trim { it <= ' ' }
        } else {
            String.format(
                "<%s (%d, %d)-(%d, %d)>", javaClass.simpleName,
                beginLine,
                beginColumn,
                endLine,
                endColumn
            )
        }
        // String output = (this instanceof Token) ? toString().trim() : getClass().getSimpleName();
        if (output.length > 0) {
            println(prefix + output)
        }
        val it: Iterator<Node> = iterator()
        while (it.hasNext()) {
            val child = it.next()
            child.dump("$prefix  ")
        }
    }

    // NB: This is not thread-safe
    // If the node's children could change out from under you,
    // you could have a problem.
    fun iterator(): MutableListIterator<Node> {
        return object : MutableListIterator<Node> {
            private var current = -1
            private var justModified = false

            override fun hasNext(): Boolean {
                return current + 1 < childCount
            }

            override fun next(): Node {
                justModified = false
                return getChild(++current)!!
            }

            override fun previous(): Node {
                justModified = false
                return getChild(--current)!!
            }

            override fun remove() {
                check(!justModified)
                removeChild(current)
                --current
                justModified = true
            }

            override fun add(n: Node) {
                check(!justModified)
                addChild(current + 1, n)
                justModified = true
            }

            override fun hasPrevious(): Boolean {
                return current > 0
            }

            override fun nextIndex(): Int {
                return current + 1
            }

            override fun previousIndex(): Int {
                return current
            }

            override fun set(element: Node) {
                setChild(current, element)
            }
        }
    }

    class Visitor {
        private var methodCache: MutableMap<Class<out Node>, Method?>? = null

        init {
            this.methodCache = mapLookup!![javaClass]
            if (methodCache == null) {
                methodCache = ConcurrentHashMap()
                mapLookup!![javaClass] = methodCache!!
            }
        }

        protected var visitUnparsedTokens: Boolean = false

        private fun getVisitMethod(node: Node): Method? {
            val nodeClass: Class<out Node> = node.javaClass
            val method = methodCache!![nodeClass]
            if (method == null) {
                methodCache!![nodeClass] = getVisitMethodImpl(nodeClass)
            }
            return methodCache!![nodeClass]
        }

        // Find handler method for this node type. If there is none, 
        // it checks for a handler for any explicitly marked interfaces
        // If necessary, it climbs the class hierarchy to superclasses
        private fun getVisitMethodImpl(nodeClass: Class<*>?): Method? {
            if (nodeClass == null || !Node::class.java.isAssignableFrom(nodeClass)) return DUMMY_METHOD
            try {
                val m = javaClass.getDeclaredMethod("visit", nodeClass)
                if (!Modifier.isPublic(nodeClass.modifiers) || !Modifier.isPublic(m.modifiers)) {
                    m.isAccessible = true
                }
                return m
            } catch (e: NoSuchMethodException) {
            }
            for (interf in nodeClass.interfaces) {
                if (Node::class.java.isAssignableFrom(interf) && Node::class.java != interf) try {
                    val m = javaClass.getDeclaredMethod("visit", interf)
                    if (!Modifier.isPublic(interf.modifiers) || !Modifier.isPublic(m.modifiers)) {
                        m.isAccessible = true
                    }
                    return m
                } catch (e: NoSuchMethodException) {
                }
            }
            return getVisitMethodImpl(nodeClass.superclass)
        }

        /**
         * Tries to invoke (via reflection) the appropriate visit(...) method
         * defined in a subclass. If there is none, it just calls the recurse() routine.
         *
         * @param node the Node to "visit"
         */
        fun visit(node: Node) {
            val visitMethod = getVisitMethod(node)
            if (visitMethod === DUMMY_METHOD) {
                recurse(node)
            } else try {
                visitMethod!!.invoke(this, node)
            } catch (ite: InvocationTargetException) {
                val cause = ite.cause
                if (cause is RuntimeException) {
                    throw cause
                }
                throw RuntimeException(ite)
            } catch (iae: IllegalAccessException) {
                throw RuntimeException(iae)
            }
        }

        /**
         * Just recurses over (i.e. visits) node's children
         *
         * @param node the node we are traversing
         */
        fun recurse(node: Node) {
            for (child in node.children(visitUnparsedTokens)) {
                visit(child)
            }
        }

        companion object {
            private var mapLookup: MutableMap<Class<out Visitor?>, MutableMap<Class<out Node>, Method?>>? = null
            private var DUMMY_METHOD: Method? = null

            init {
                try {
                    // Use this just to represent no method found, since ConcurrentHashMap cannot contains nulls
                    DUMMY_METHOD = Any::class.java.getMethod("toString")
                } catch (e: Exception) {
                    throw RuntimeException(e)
                }
                // Never happens anyway.
                mapLookup = Collections.synchronizedMap(HashMap())
            }
        }
    }

    companion object {
        fun getTokens(node: Node): List<Token> {
            val result: MutableList<Token> = ArrayList()
            for (child in node.children()) {
                if (child is Token) {
                    result.add(child)
                } else {
                    result.addAll(getTokens(child))
                }
            }
            return result
        }

        fun getRealTokens(n: Node): List<Token> {
            val result: MutableList<Token> = ArrayList()
            for (token in getTokens(n)) {
                if (!token.isUnparsed) {
                    result.add(token)
                }
            }
            return result
        }
    }
}


