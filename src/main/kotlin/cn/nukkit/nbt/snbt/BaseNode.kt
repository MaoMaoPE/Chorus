/* Generated by: JavaCC 21 Parser Generator. Do not edit. BaseNode.java */
package cn.nukkit.nbt.snbt

import java.util.*
import kotlin.collections.ArrayList
import kotlin.collections.HashMap
import kotlin.collections.List
import kotlin.collections.MutableList
import kotlin.collections.MutableMap
import kotlin.collections.set

/**
 * The base concrete class for non-terminal Nodes
 */
open class BaseNode : Node {
    override var tokenSource: SNBTLexer? = null
        get() {
            if (field == null) {
                for (child in children()) {
                    field = child.tokenSource
                    if (field != null) break
                }
            }
            return field
        }

    private fun newList(): MutableList<Node> {
        if (listClass == null) {
            return ArrayList()
        }
        try {
            return listClass!!.getDeclaredConstructor().newInstance() as MutableList<Node>
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }

    /**
     * the parent node
     */
    override var parent: Node? = null

    /**
     * the child nodes
     */
    private val children = newList()
    override var beginOffset: Int = 0
    override var endOffset: Int = 0
    override var isUnparsed: Boolean = false

    override fun addChild(n: Node) {
        children.add(n)
        n.parent = this
    }

    override fun addChild(i: Int, n: Node) {
        children.add(i, n)
        n.parent = this
    }

    override fun getChild(i: Int): Node? {
        return children[i]
    }

    override fun setChild(i: Int, n: Node) {
        children[i] = n
        n.parent = this
    }

    override fun removeChild(i: Int): Node? {
        return children.removeAt(i)
    }

    override fun clearChildren() {
        children.clear()
    }

    override val childCount: Int
        get() = children.size

    override fun children(): List<Node> {
        return Collections.unmodifiableList(children)
    }

    override fun toString(): String {
        val buf = StringBuilder()
        for (t in realTokens) {
            buf.append(t)
        }
        return buf.toString()
    }

    private var namedChildMap: MutableMap<String, Node>? = null
    private var namedChildListMap: MutableMap<String, MutableList<Node>>? = null

    fun getNamedChild(name: String): Node? {
        if (namedChildMap == null) {
            return null
        }
        return namedChildMap!![name]
    }

    fun setNamedChild(name: String, node: Node) {
        if (namedChildMap == null) {
            namedChildMap = HashMap()
        }
        if (namedChildMap!!.containsKey(name)) {
            // Can't have duplicates
            val msg = String.format("Duplicate named child not allowed: {0}", name)
            throw RuntimeException(msg)
        }
        namedChildMap!![name] = node
    }

    fun getNamedChildList(name: String): List<Node>? {
        if (namedChildListMap == null) {
            return null
        }
        return namedChildListMap!![name]
    }

    fun addToNamedChildList(name: String, node: Node) {
        if (namedChildListMap == null) {
            namedChildListMap = HashMap()
        }
        var nodeList = namedChildListMap!![name]
        if (nodeList == null) {
            nodeList = ArrayList()
            namedChildListMap!![name] = nodeList
        }
        nodeList.add(node)
    }

    companion object {
        private var listClass: Class<out MutableList<*>?>? = null

        /**
         * Sets the List class that is used to store child nodes. By default,
         * this is java.util.ArrayList. There is probably very little reason
         * to ever use anything else, though you could use this method
         * to replace this with LinkedList or your own java.util.List implementation even.
         *
         * @param listClass the #java.util.List implementation to use internally
         * for the child nodes. By default #java.util.ArrayList is used.
         */
        fun setListClass(listClass: Class<out MutableList<*>?>?) {
            Companion.listClass = listClass
        }
    }
}


